section#cover.slide
    h2 Neo4j Graph Database
    p
        | by Mateusz Jaworski
        br
        | February 2016

section.slide
    h2 Why graph database?
    ul
        li nodes and relations are first class citizens
        li constant time for neighbour lookups

section.slide
    h2 Why graph database?
    ul
        li give me all neighbours of A in N hops
        li give me all paths from A to B
        li give me the shortest path from A to B
        li is there a node D on path between A and B

section.slide
    h2 Neo4j features
    ol
        li 1.0 released in February 2010
        li licensing
            ul
                li community (GPLv3, 1 node)
                li enterprise (clustering, backup, monitoring, free for open source projects)
                li government
        li cypher query language (via HTTP)

section.slide
    img#ranking(src='images/ranking.png')
    style.
        #ranking {
            height: 500px;
            display: block;
            margin-top: -40px;
            margin-left: auto;
            margin-right: auto;
        }

section.slide
    h2 Neo4j features
    ol
        li properties - on nodes and edges (primitives or array of primitives)
        li labels - on nodes and edges
        li indexes - on node properties
        li constraints - on nodes or relations
        li ACID transactions

section.slide
    h2 ACID
    ol
        li Neo4j claims to be ACID compliant
        li but... ACID in distributed database?
        li but... CAP theorem? (consistency, availability, partition tolerance)
        li ACID transactions (READ_COMMITTED by default)
    p.note
        a(href='http://neo4j.com/docs/stable/transactions.html') more: transaction management

section.slide
    h2 Built-in algorithms
    ol
        li shortest paths
        li all paths
        li all simple paths (no repeated nodes)
        li Dijkstra (shortest path with weights)
        li A* (shortest path with heuristic)

section.slide
    h2 Cypher
    pre
        code.cypher.
            MATCH (user)-[:friend]->(follower)
            WHERE user.name IN ['Joe', 'John']
                AND follower.name =~ 'S.*'
            RETURN user.name, follower.name

section.slide
    h2 Cypher
    pre
        code.cypher.
            MATCH (a)--(b)
            MATCH (a)-[:friend]->(b)-->(c)
            MATCH (a:A { name:'alice' })-[:friend {x:y}]-(b:B)
            MATCH (a)-[:friend*1..3]->(b)

section.slide
    h2 Cypher
    pre
        code.cypher.
            MATCH (tobias { name: 'Tobias' }),(others)
            WHERE others.name IN ['A', 'B'] AND (tobias)<--(others)
            RETURN others

            MATCH (n { name: 'A' })-->(x)
            RETURN n as n, count(*), avg(n.value)
            ORDER BY n ASC LIMIT 10

section.slide
    h2.centered Live demo

section.slide
    h2 Shell commands
    ol
        li :play start
        li :server connect
        li :clear
        li :history
        li :style [reset]
        li :config maxRows:100


section.slide
    h2 Alternatives
    ol
        li OrientDB &nbsp;
            a(href="http://orientdb.com/") http://orientdb.com/
        li ArangoDB &nbsp;
            a(href="https://www.arangodb.com/") https://www.arangodb.com/
        li Titan &nbsp;
            a(href="http://thinkaurelius.github.io/titan/") http://thinkaurelius.github.io/titan/
        li Virtuoso &nbsp;
            a(href="http://virtuoso.openlinksw.com/") http://virtuoso.openlinksw.com/

section.slide
    h2.centered Questions?

section.slide
    h2.centered Thanks!

